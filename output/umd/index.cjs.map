{"version":3,"file":"index.cjs","sources":["../src/maybe.ts","../src/result.ts"],"sourcesContent":["import { Chainable, Flattened } from './chainable';\n\ninterface MaybeChain<T> extends Chainable<T> {\n  something?: boolean;\n  __isMaybe: true;\n  chain: <ReturnType>(\n    this: Maybe<T>,\n    fn: (v: NonNullable<T>) => Maybe<ReturnType>,\n  ) => Maybe<ReturnType>;\n  flatten: () => Flattened<T, Maybe<T>>;\n  then: <ReturnType>(\n    this: Maybe<T>,\n    fn: (v: NonNullable<T>) => ReturnType | Maybe<ReturnType>,\n  ) => Maybe<ReturnType>;\n  orElse: (mElse: NonNullable<T>) => NonNullable<T>;\n}\nexport interface Something<T> extends MaybeChain<T> {\n  something: true;\n  value: NonNullable<T>;\n}\nexport interface Nothing<T> extends MaybeChain<T> {\n  something: false;\n}\n\nclass MB<T> implements MaybeChain<T> {\n  public something: boolean;\n  public value: T | undefined;\n  public __isMaybe: true = true;\n\n  public chain<R>(this: Maybe<T>, fn: (v: NonNullable<T>) => Maybe<R>): Maybe<R> {\n    return this.something ? fn(this.value) : Nothing();\n  }\n\n  public flatten() {\n    if (this.something) {\n      const val = this.value;\n      if (typeof val === 'object' && '__isMaybe' in val) {\n        return val as Flattened<T, Maybe<T>>;\n      }\n    }\n    // Rewrap the value in a maybe so there is a new object\n    return Maybe(this.value) as Flattened<T, Maybe<T>>;\n  }\n\n  public then<F>(this: Maybe<T>, fn: (v: NonNullable<T>) => F | Maybe<F>): Maybe<F> {\n    return this.chain((v) => Maybe(fn(v))).flatten() as Maybe<F>;\n  }\n\n  public orElse(mElse: NonNullable<T>): NonNullable<T> {\n    return this.something ? this.value! : mElse;\n  }\n}\n\nexport type Maybe<T> = Nothing<T> | Something<T>;\n\nconst makeMaybe = <F>(): MaybeChain<F> => {\n  return new MB<F>();\n};\n// Need to use assign so that the object remains correctly bound to the methods.\nexport const Nothing = <T>(): Nothing<T> => {\n  return Object.assign<MaybeChain<T>, { something: false }>(makeMaybe<T>(), {\n    something: false,\n  });\n};\n\nexport const Something = <T>(value: NonNullable<T>): Something<T> => {\n  if (value === undefined || value === null) {\n    throw new Error('Maybe.Just cannot be undefined or null');\n  }\n  return Object.assign<MaybeChain<T>, { something: true; value: NonNullable<T> }>(makeMaybe<T>(), {\n    something: true,\n    value: value,\n  });\n};\n\nexport const MaybeDictionary = <T>(dictionary: {\n  [key: string]: T;\n}): { [key: string]: Maybe<T> } => {\n  return new Proxy<{ [key: string]: Maybe<T> }>(\n    dictionary as unknown as { [key: string]: Maybe<T> },\n    {\n      get: (target: { [key: string]: Maybe<T> | T }, name: string): Maybe<T> => {\n        const value = target[name];\n        if (!value || !('__isMaybe' in value)) {\n          const mb = Maybe(value);\n          target[name] = mb;\n          return mb;\n        }\n        return value;\n      },\n    },\n  );\n};\nexport const isSomething = <T>(val: Maybe<T>): val is Something<T> => {\n  return val.something;\n};\n\nexport const isNothing = <T>(val: Maybe<T>): val is Nothing<T> => {\n  return !val.something;\n};\n\nexport const Maybe = <T>(value: T | undefined | null): Maybe<T> => {\n  return value !== undefined && value !== null ? Something(value!) : Nothing();\n};\n","import { Chainable, Flattened } from './chainable';\n\nexport interface Ok<R, E> extends ResultInternal<R, E> {\n  ok: true;\n  value: R;\n}\n\nexport interface Err<R, E> extends ResultInternal<R, E> {\n  ok: false;\n  value: E;\n}\n\nclass ResultInternal<R, E> implements Chainable<R> {\n  public ok: boolean;\n  public value: R | E;\n\n  public constructor(options: { ok: boolean; value: R | E }) {\n    this.ok = options.ok;\n    this.value = options.value;\n  }\n\n  public chain<T>(this: Result<R, E>, fn: (v: R) => Result<T, E>): Result<T, E> {\n    if (this.ok) {\n      return fn(this.value);\n    }\n    return Err(this.value);\n  }\n\n  public bothChain<R2, E2>(\n    this: Result<R, E>,\n    fnOk: (v: R) => Result<R2, E2>,\n    fnErr: (v: E) => Result<R2, E2>,\n  ): Result<R2, E2> {\n    if (this.ok) {\n      return fnOk(this.value);\n    }\n    return fnErr(this.value);\n  }\n\n  /**\n   * Works just like chain, but is only called if this Result is an error.\n   * This returns a new Result with type Result<R, NewType>\n   */\n  public errChain<T>(this: Result<R, E>, fn: (v: E) => Result<R, T>): Result<R, T> {\n    if (!this.ok) {\n      return fn(this.value);\n    }\n    return Ok(this.value);\n  }\n\n  public flatten(): Flattened<R, Result<R, E>> {\n    if (this.value && this.value instanceof ResultInternal) {\n      return this.value as Flattened<R, Result<R, E>>;\n    }\n    return this as unknown as Flattened<R, Result<R, E>>;\n  }\n\n  /**\n   * This allows users to opperate on a presumed result without needing to know whether or not\n   * the result was successful or not.\n   * At each call if it is a result type of ok, it will call the supplied function, otherwise it\n   * will return the current value with a new Err.\n   *\n   * @param fnOk Function that takes in an ok value of type R and returns either F or Result<F,E>\n   */\n  public then<F>(this: Result<R, E>, fnOk: (v: R) => F | Result<F, E>): Result<F, E> {\n    if (this.ok) {\n      return Ok(fnOk(this.value)).flatten() as Result<F, E>;\n    }\n\n    return Err(this.value);\n  }\n\n  /**\n   * Works just like then, but is only called if this Result is an error.\n   * This returns a new Result with type Result<R, NewType>\n   */\n  public errThen<F>(this: Result<R, E>, fnErr: (v: E) => F | Result<R, F>): Result<R, F> {\n    if (!this.ok) {\n      return Err(fnErr(this.value)).flatten() as Result<R, F>;\n    }\n\n    return Ok(this.value);\n  }\n\n  public okOrElse(this: Result<R, E>, okElse: R): R {\n    if (this.ok) {\n      return this.value;\n    }\n    return okElse;\n  }\n\n  public errOrElse(this: Result<R, E>, errElse: E): E {\n    if (!this.ok) {\n      return this.value;\n    }\n    return errElse;\n  }\n\n  /**\n   * Takes in two functions, one which takes type R and the other which takes type E and both return\n   * type T. This lets you handle either case and potentially return a unifying type. You might use this\n   * to create a message for users.\n   *\n   * @param fnOk Function that maps from Ok value(R) to new type T\n   * @param fnErr Function that maps from Err value(E) to new type T\n   */\n  public resolve<T>(this: Result<R, E>, fnOk: (v: R) => T, fnErr: (v: E) => T): T {\n    if (this.ok) {\n      return fnOk(this.value);\n    }\n    return fnErr(this.value);\n  }\n\n  /**\n   * This function will either return the current Ok value or use\n   * the function provided to generate that from the Err value that it contains\n   * @param fnErr Function that maps from Err value(E) to current type R\n   */\n  public resolveOk(this: Result<R, E>, fnErr: (v: E) => R): R {\n    if (this.ok) {\n      return this.value;\n    }\n    return fnErr(this.value);\n  }\n\n  /**\n   * This function will either return the current Err value or use\n   * the function provided to generate that from the Ok value that it contains\n   *\n   * @param fnOk Function that maps from Ok value(R) to current type E\n   */\n  public resolveErr(this: Result<R, E>, fnOk: (v: R) => E): E {\n    if (this.ok) {\n      return fnOk(this.value);\n    }\n    return this.value;\n  }\n}\n\nexport const Ok = <R, E>(value: R): Ok<R, E> => {\n  return new ResultInternal<R, E>({ value: value, ok: true }) as Ok<R, E>;\n};\n\nexport const Err = <R, E>(value: E): Err<R, E> => {\n  return new ResultInternal<R, E>({ value: value, ok: false }) as Err<R, E>;\n};\n\n/**\n * Result is a useful type for when you might want to handle errors down the line without swallowing them\n * while still preforming potentially several operations that could result in an error. A simple example could\n * be a dividing function that returns a Result. Instead of throwing an error that you cannot divide by zero,\n * it would be returned in an Err. This allows the rest of the program to execute cleanly.\n */\nexport type Result<R, E> = Err<R, E> | Ok<R, E>;\n\nexport const isOk = <R, E>(r: Result<R, E>): r is Ok<R, E> => {\n  return r.ok;\n};\n\nexport const isErr = <R, E>(r: Result<R, E>): r is Err<R, E> => {\n  return !r.ok;\n};\n\nexport const partitionResults = <R, E>(results: Result<R, E>[]): [R[], E[]] => {\n  return results.reduce<[R[], E[]]>(\n    (acc, value) => {\n      if (value.ok) {\n        acc[0].push(value.value);\n      } else {\n        acc[1].push(value.value);\n      }\n      return acc;\n    },\n    [[], []],\n  );\n};\n"],"names":[],"mappings":"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"}