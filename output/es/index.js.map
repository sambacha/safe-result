{"version":3,"file":"index.js","sources":["../src/maybe.ts","../src/result.ts"],"sourcesContent":["import { Chainable, Flattened } from './chainable';\n\ninterface MaybeChain<T> extends Chainable<T> {\n  something?: boolean;\n  __isMaybe: true;\n  chain: <ReturnType>(\n    this: Maybe<T>,\n    fn: (v: NonNullable<T>) => Maybe<ReturnType>,\n  ) => Maybe<ReturnType>;\n  flatten: () => Flattened<T, Maybe<T>>;\n  then: <ReturnType>(\n    this: Maybe<T>,\n    fn: (v: NonNullable<T>) => ReturnType | Maybe<ReturnType>,\n  ) => Maybe<ReturnType>;\n  orElse: (mElse: NonNullable<T>) => NonNullable<T>;\n}\nexport interface Something<T> extends MaybeChain<T> {\n  something: true;\n  value: NonNullable<T>;\n}\nexport interface Nothing<T> extends MaybeChain<T> {\n  something: false;\n}\n\nclass MB<T> implements MaybeChain<T> {\n  public something: boolean;\n  public value: T | undefined;\n  public __isMaybe: true = true;\n\n  public chain<R>(this: Maybe<T>, fn: (v: NonNullable<T>) => Maybe<R>): Maybe<R> {\n    return this.something ? fn(this.value) : Nothing();\n  }\n\n  public flatten() {\n    if (this.something) {\n      const val = this.value;\n      if (typeof val === 'object' && '__isMaybe' in val) {\n        return val as Flattened<T, Maybe<T>>;\n      }\n    }\n    // Rewrap the value in a maybe so there is a new object\n    return Maybe(this.value) as Flattened<T, Maybe<T>>;\n  }\n\n  public then<F>(this: Maybe<T>, fn: (v: NonNullable<T>) => F | Maybe<F>): Maybe<F> {\n    return this.chain((v) => Maybe(fn(v))).flatten() as Maybe<F>;\n  }\n\n  public orElse(mElse: NonNullable<T>): NonNullable<T> {\n    return this.something ? this.value! : mElse;\n  }\n}\n\nexport type Maybe<T> = Nothing<T> | Something<T>;\n\nconst makeMaybe = <F>(): MaybeChain<F> => {\n  return new MB<F>();\n};\n// Need to use assign so that the object remains correctly bound to the methods.\nexport const Nothing = <T>(): Nothing<T> => {\n  return Object.assign<MaybeChain<T>, { something: false }>(makeMaybe<T>(), {\n    something: false,\n  });\n};\n\nexport const Something = <T>(value: NonNullable<T>): Something<T> => {\n  if (value === undefined || value === null) {\n    throw new Error('Maybe.Just cannot be undefined or null');\n  }\n  return Object.assign<MaybeChain<T>, { something: true; value: NonNullable<T> }>(makeMaybe<T>(), {\n    something: true,\n    value: value,\n  });\n};\n\nexport const MaybeDictionary = <T>(dictionary: {\n  [key: string]: T;\n}): { [key: string]: Maybe<T> } => {\n  return new Proxy<{ [key: string]: Maybe<T> }>(\n    dictionary as unknown as { [key: string]: Maybe<T> },\n    {\n      get: (target: { [key: string]: Maybe<T> | T }, name: string): Maybe<T> => {\n        const value = target[name];\n        if (!value || !('__isMaybe' in value)) {\n          const mb = Maybe(value);\n          target[name] = mb;\n          return mb;\n        }\n        return value;\n      },\n    },\n  );\n};\nexport const isSomething = <T>(val: Maybe<T>): val is Something<T> => {\n  return val.something;\n};\n\nexport const isNothing = <T>(val: Maybe<T>): val is Nothing<T> => {\n  return !val.something;\n};\n\nexport const Maybe = <T>(value: T | undefined | null): Maybe<T> => {\n  return value !== undefined && value !== null ? Something(value!) : Nothing();\n};\n","import { Chainable, Flattened } from './chainable';\n\nexport interface Ok<R, E> extends ResultInternal<R, E> {\n  ok: true;\n  value: R;\n}\n\nexport interface Err<R, E> extends ResultInternal<R, E> {\n  ok: false;\n  value: E;\n}\n\nclass ResultInternal<R, E> implements Chainable<R> {\n  public ok: boolean;\n  public value: R | E;\n\n  public constructor(options: { ok: boolean; value: R | E }) {\n    this.ok = options.ok;\n    this.value = options.value;\n  }\n\n  public chain<T>(this: Result<R, E>, fn: (v: R) => Result<T, E>): Result<T, E> {\n    if (this.ok) {\n      return fn(this.value);\n    }\n    return Err(this.value);\n  }\n\n  public bothChain<R2, E2>(\n    this: Result<R, E>,\n    fnOk: (v: R) => Result<R2, E2>,\n    fnErr: (v: E) => Result<R2, E2>,\n  ): Result<R2, E2> {\n    if (this.ok) {\n      return fnOk(this.value);\n    }\n    return fnErr(this.value);\n  }\n\n  /**\n   * Works just like chain, but is only called if this Result is an error.\n   * This returns a new Result with type Result<R, NewType>\n   */\n  public errChain<T>(this: Result<R, E>, fn: (v: E) => Result<R, T>): Result<R, T> {\n    if (!this.ok) {\n      return fn(this.value);\n    }\n    return Ok(this.value);\n  }\n\n  public flatten(): Flattened<R, Result<R, E>> {\n    if (this.value && this.value instanceof ResultInternal) {\n      return this.value as Flattened<R, Result<R, E>>;\n    }\n    return this as unknown as Flattened<R, Result<R, E>>;\n  }\n\n  /**\n   * This allows users to opperate on a presumed result without needing to know whether or not\n   * the result was successful or not.\n   * At each call if it is a result type of ok, it will call the supplied function, otherwise it\n   * will return the current value with a new Err.\n   *\n   * @param fnOk Function that takes in an ok value of type R and returns either F or Result<F,E>\n   */\n  public then<F>(this: Result<R, E>, fnOk: (v: R) => F | Result<F, E>): Result<F, E> {\n    if (this.ok) {\n      return Ok(fnOk(this.value)).flatten() as Result<F, E>;\n    }\n\n    return Err(this.value);\n  }\n\n  /**\n   * Works just like then, but is only called if this Result is an error.\n   * This returns a new Result with type Result<R, NewType>\n   */\n  public errThen<F>(this: Result<R, E>, fnErr: (v: E) => F | Result<R, F>): Result<R, F> {\n    if (!this.ok) {\n      return Err(fnErr(this.value)).flatten() as Result<R, F>;\n    }\n\n    return Ok(this.value);\n  }\n\n  public okOrElse(this: Result<R, E>, okElse: R): R {\n    if (this.ok) {\n      return this.value;\n    }\n    return okElse;\n  }\n\n  public errOrElse(this: Result<R, E>, errElse: E): E {\n    if (!this.ok) {\n      return this.value;\n    }\n    return errElse;\n  }\n\n  /**\n   * Takes in two functions, one which takes type R and the other which takes type E and both return\n   * type T. This lets you handle either case and potentially return a unifying type. You might use this\n   * to create a message for users.\n   *\n   * @param fnOk Function that maps from Ok value(R) to new type T\n   * @param fnErr Function that maps from Err value(E) to new type T\n   */\n  public resolve<T>(this: Result<R, E>, fnOk: (v: R) => T, fnErr: (v: E) => T): T {\n    if (this.ok) {\n      return fnOk(this.value);\n    }\n    return fnErr(this.value);\n  }\n\n  /**\n   * This function will either return the current Ok value or use\n   * the function provided to generate that from the Err value that it contains\n   * @param fnErr Function that maps from Err value(E) to current type R\n   */\n  public resolveOk(this: Result<R, E>, fnErr: (v: E) => R): R {\n    if (this.ok) {\n      return this.value;\n    }\n    return fnErr(this.value);\n  }\n\n  /**\n   * This function will either return the current Err value or use\n   * the function provided to generate that from the Ok value that it contains\n   *\n   * @param fnOk Function that maps from Ok value(R) to current type E\n   */\n  public resolveErr(this: Result<R, E>, fnOk: (v: R) => E): E {\n    if (this.ok) {\n      return fnOk(this.value);\n    }\n    return this.value;\n  }\n}\n\nexport const Ok = <R, E>(value: R): Ok<R, E> => {\n  return new ResultInternal<R, E>({ value: value, ok: true }) as Ok<R, E>;\n};\n\nexport const Err = <R, E>(value: E): Err<R, E> => {\n  return new ResultInternal<R, E>({ value: value, ok: false }) as Err<R, E>;\n};\n\n/**\n * Result is a useful type for when you might want to handle errors down the line without swallowing them\n * while still preforming potentially several operations that could result in an error. A simple example could\n * be a dividing function that returns a Result. Instead of throwing an error that you cannot divide by zero,\n * it would be returned in an Err. This allows the rest of the program to execute cleanly.\n */\nexport type Result<R, E> = Err<R, E> | Ok<R, E>;\n\nexport const isOk = <R, E>(r: Result<R, E>): r is Ok<R, E> => {\n  return r.ok;\n};\n\nexport const isErr = <R, E>(r: Result<R, E>): r is Err<R, E> => {\n  return !r.ok;\n};\n\nexport const partitionResults = <R, E>(results: Result<R, E>[]): [R[], E[]] => {\n  return results.reduce<[R[], E[]]>(\n    (acc, value) => {\n      if (value.ok) {\n        acc[0].push(value.value);\n      } else {\n        acc[1].push(value.value);\n      }\n      return acc;\n    },\n    [[], []],\n  );\n};\n"],"names":[],"mappings":"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"}